---
layout:  post
title:  《netty权威指南》读书笔记（一）--linux网络I/O模型简介
date: 2019-07-02 13:32:20 +0300
tags: [netty,nio,计算机网络]
typora-root-url: .
typora-copy-images-to: ..\assets\clipimg
---



## linux网络I/O模型简介

linux的内核将所有外部设备都看作一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor（fd，文件描述符）。而对一个socket的读写也会有相应的描述符，称为socketfd（socket描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。

 

UNIX提供了5种I/O模型，分别如下。

**阻塞I/O模型：**再进程空间中调用recvfrom，其系统调用直到数据包到达切且被复制到应用进程的缓冲区中发生错误时才返回，在此期间一直会等待。

**非阻塞I/O模型：**recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来。

![阻塞和非阻塞模型 ](/../assets/clipimg/clip_image001-1562314967043.png)

**I/O复用模型：**Linux提供select/poll,      进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。Linux      还提供了一个epoll 系统调用，epoll      使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback,如图1-3 所示。

**信号驱动I/O模型：**首先开启套接口信号驱动I/O功能,并通过系统调用sigaction执行一个信号处理函数(此系统调用立即返回，进程继续工作，它是非阻塞的)。当数据准备就绪时，就为该进程生成-一个SIGIO信号,通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据，如图1-4所示。

**异步I/O：**告知内核启动某个操作，并让内核在整个操作完成后(包括将数据从内核复制到用户自己的缓冲区)通知我们。这种模型与信号驱动模型的主要区别是:信号驱动I/O由内核通知我们何时可以开始一个I/O操作;异步1/O模型由内核通知我们I/O操作何时已经完成，如图1-5所示。

![I/O复用和信号驱动模型 ](/../assets/clipimg/clip_image002-1562314998506.png)

 

## I/O多路复用技术

I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。

 

支持I/O多路复用的系统调用：select（轮询）、 pselect、 poll、 epoll

 

epoll对select的改进：

1. 支持一个进程打开的socket描述符(      FD )不受限制(仅受限于操作系统的最大文件句柄数)。select默认最多为1024。
2. I/O效率不会随着FD数目的增加而线性下降。因为select是轮询的需要线性扫描全部的集合，导致效率线性下降。epoll只对“活跃的”socket进行操作--因为在内核实现中，epoll是根据每个fd上面的callback函数实现的。
3. 使用mmap加速内核与用户空间的消息传递。
4. epoll的API更加简单。

